#!/usr/bin/env python

import sys
import os
import logging
import argparse
import inflection
import re
from pydoc import locate
from tasks import utils

CONGRESS_ROOT = os.path.dirname(os.path.abspath(__file__))


def main(task_name, options):

    # read in an opt-in config file for changing directories and supplying email settings
    # returns None if it's not there, and this should always be handled gracefully
    path = options.get('config', 'config.yml')
    if os.path.exists(path):
        # Don't use a cached config file, just in case, and direct_yaml_load is not yet defined.
        import yaml
        config = yaml.load(open(path))
    else:
        config = {}

    # configure logging
    log_level = 'debug' if options.get('debug', False) else options.get('log', 'warn')
    if log_level not in ['debug', 'info', 'warn', 'error']:
        print 'Invalid log level (specify: debug, info, warn, error).'
        sys.exit(1)

    if options.get('timestamps', False):
        logging.basicConfig(format='%(asctime)s %(message)s', level=log_level.upper())
    else:
        logging.basicConfig(format='%(message)s', level=log_level.upper())

    try:
        task = locate('tasks.{0}.{1}'.format(task_name, inflection.camelize(task_name)))(options, config)
        task.run()
    except Exception as exception:
        utils.admin(exception)
        sys.exit(1)

if __name__ == '__main__':

    parser = argparse.ArgumentParser(description='Scrapes federal congressional data.')
    parser.add_argument('task_name', type=str,
                        help='The task name to run from modules in the "tasks" package.')
    parser.add_argument('options', type=str, nargs=argparse.REMAINDER,
                        help='Additional options to supply task in --key=value format.')

    args = parser.parse_args()

    def parse_opt(opt):
        if re.search(r'^--\w+(=)?\w*', opt):
            key, value = opt.split('=') if '=' in opt else (opt, True)
            return key[2:], value
        else:
            raise ValueError('Option input must confirm to pattern of form --option or --option=list[,of[,values]]')

    main(args.task_name, dict([parse_opt(option) for option in args.options]))
